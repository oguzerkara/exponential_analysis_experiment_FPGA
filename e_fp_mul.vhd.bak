library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity e_fp_mul is
    generic (
        G_EXP_BITS  : integer := 8;   -- Exponent bits for single precision
        G_FRAC_BITS : integer := 23;   -- Fraction bits for single precision
        CYCLES      : integer := 4    -- Number of cycles for computation
    );
    port (
        clk    : in  std_logic;
        reset  : in  std_logic;
        start  : in  std_logic; -- Start signal
        in_a   : in  std_logic_vector((1+G_EXP_BITS+G_FRAC_BITS)-1 downto 0); -- 32-bit float
        in_b   : in  std_logic_vector((1+G_EXP_BITS+G_FRAC_BITS)-1 downto 0); -- 32-bit float
        done   : out std_logic; -- Done signal
        result : out std_logic_vector((1+G_EXP_BITS+G_FRAC_BITS)-1 downto 0)
    );
end entity e_fp_mul;

architecture Behavioral of e_fp_mul is
    constant EXP_BIAS : integer := 127;

    -- Extract fields
    signal sign_a, sign_b : std_logic;
    signal exp_a, exp_b   : unsigned(G_EXP_BITS-1 downto 0);
    signal frac_a, frac_b : unsigned(G_FRAC_BITS downto 0);  -- 1 + 23 bits
    signal result_sign    : std_logic;
    signal result_exp     : unsigned(G_EXP_BITS-1 downto 0);
    -- signal result_frac    : unsigned(G_FRAC_BITS downto 0);

    -- For multiplication:
    -- 24-bit mantissas (including hidden bit) -> 48-bit product
    signal product : unsigned((G_FRAC_BITS+1)*2-1 downto 0); -- 47 downto 0
    signal norm_frac : unsigned(G_FRAC_BITS downto 0);
    signal temp_exp  : integer;

    -- State Definitions
    type state_type is (IDLE, COMPUTE, COMPUTE_DONE);
    signal current_state, next_state : state_type := IDLE;
	 
    -- Additional signals
    signal compute_counter : integer range 0 to CYCLES := 0; -- Adjust range based on required cycles
    signal computation_finished : std_logic := '0';

begin
    -- State Machine Process
    process(clk, reset)
    begin
        if reset = '1' then
            current_state <= IDLE;
        elsif rising_edge(clk) then
            current_state <= next_state;
        end if;
    end process;

    -- Next State Logic
    process(current_state, start, computation_finished)
    begin
        next_state <= current_state; -- Default to stay in current state
        case current_state is
            when IDLE =>
                if start = '1' then
                    next_state <= COMPUTE; -- Start computation when start signal is high
                else	
						  next_state <= IDLE;
					 end if;

            when COMPUTE =>
                if computation_finished = '1' then
                    next_state <= COMPUTE_DONE;
                else
                    next_state <= COMPUTE; -- Remain in COMPUTE until finished
                end if;

            when COMPUTE_DONE =>
                if start = '0' then
                    next_state <= COMPUTE_DONE; -- Return to IDLE after start signal goes low
					 else 
						  next_state <= IDLE;
					 end if;

            when others =>
                next_state <= IDLE;
        end case;
    end process;

    -- Output and Computation Process
    process(clk, reset)
    begin
        if reset = '1' then
            done <= '0';
            result <= (others => '0');
            compute_counter <= 0;
            computation_finished <= '0';
        elsif rising_edge(clk) then
            case current_state is
                when IDLE =>
                    done <= '0';
						  compute_counter <= 0;
						  computation_finished <= '0';

                when COMPUTE =>
						-- Increment counter and perform computation
                    if compute_counter = CYCLES then -- Adjust the number of cycles as needed
                        computation_finished <= '1';
                    else
                        compute_counter <= compute_counter + 1;                        computation_finished <= '1';
                        computation_finished <= '0';
							  done <= '0';
							  
							  -- Extract sign
							  sign_a <= in_a(31);
							  sign_b <= in_b(31);

							  -- Extract exponent
							  exp_a <= unsigned(in_a(30 downto 23));
							  exp_b <= unsigned(in_b(30 downto 23));

							  -- Extract fraction (with leading 1)
							  frac_a <= "1" & unsigned(in_a(22 downto 0));
							  frac_b <= "1" & unsigned(in_b(22 downto 0));

							  -- Determine result sign
							  result_sign <= sign_a xor sign_b;

							  -- Add exponents and subtract bias
							  temp_exp <= (to_integer(exp_a) + to_integer(exp_b)) - EXP_BIAS;

							  -- Multiply mantissas (24 bits each)
							  product <= unsigned(frac_a) * unsigned(frac_b); 
							  -- product is 48 bits now

							  -- Normalize the product:
							  if product(47) = '1' then
									norm_frac <= product(47 downto 24); -- Taking the top 24 bits after shift
									temp_exp <= temp_exp + 1;
							  else
									norm_frac <= product(46 downto 23); -- These 24 bits represent 1.Fraction
							  end if;

							  -- Compute exponent
							  result_exp <= to_unsigned(temp_exp, G_EXP_BITS);

							  -- Construct output
							  result <= result_sign & std_logic_vector(result_exp) & std_logic_vector(norm_frac(G_FRAC_BITS-1 downto 0));
						end if;
                when COMPUTE_DONE =>
                    done <= '1'; -- Signal computation is complete	  
						  result <= result_sign & std_logic_vector(result_exp) & std_logic_vector(norm_frac(G_FRAC_BITS-1 downto 0));

						  compute_counter <= 0;
						  computation_finished <= '0';
                when others =>
                    done <= '0';
						  compute_counter <= 0;
						  computation_finished <= '0';
				  end case;
        end if;
    end process;

end Behavioral;
