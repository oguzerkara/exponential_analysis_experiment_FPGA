library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity tle_exponential_smoothing is
    port (
        clk          : in  std_logic;
        reset        : in  std_logic;
        smoothed_out: out std_logic_vector(31 downto 0)  -- Smoothed value
    );
end entity tle_exponential_smoothing;

architecture behavioral of tle_exponential_smoothing is

    -- Component Declarations
	 
	 component e_exponential_smoothing

		  port (
				clk			  : in std_logic;
				reset			  : in std_logic;
				process_start : in std_logic;
				process_done  : out std_logic;
				processed_out : out std_logic_vector(31 downto 0);  -- Smoothed value
				
			   ram_data_out  : in std_logic_vector(63 downto 0);
			   ram_address	  : out std_logic_vector(9 downto 0);
			   ram_data_in	  : out std_logic_vector(63 downto 0);
			   ram_wren		  : out std_logic;
			   ram_rden		  : out std_logic				
				);
	end component;
				
    component e_write_and_read_ram
        port (
            clk           : in  std_logic;
            reset         : in  std_logic;
            write_done    : out std_logic;
            read_done     : out std_logic;
				
			   ram_data_out  : in std_logic_vector(63 downto 0);
			   ram_address	  : out std_logic_vector(9 downto 0);
			   ram_data_in	  : out std_logic_vector(63 downto 0);
			   ram_wren		  : out std_logic;
			   ram_rden		  : out std_logic	
        );
	end component;

    component config_ram
        port (
            address : in  std_logic_vector(9 downto 0);
            clock   : in  std_logic;
            data    : in  std_logic_vector(63 downto 0);
            rden    : in  std_logic;
            wren    : in  std_logic;
            q       : out std_logic_vector(63 downto 0)
        );
    end component;

	 -- Signals for RAM Interface
    signal mux_ram_address  : std_logic_vector(9 downto 0);
    signal mux_ram_data_in  : std_logic_vector(63 downto 0);
    signal mux_ram_data_out : std_logic_vector(63 downto 0);
    signal mux_ram_wren     : std_logic;
    signal mux_ram_rden     : std_logic;

    -- Signals from e_write_and_read_ram
    signal e_rnW_ram_address  : std_logic_vector(9 downto 0);
    signal e_rnW_ram_data_in  : std_logic_vector(63 downto 0);
    signal e_rnW_ram_data_out : std_logic_vector(63 downto 0) := (others => '0');
    signal e_rnW_ram_wren     : std_logic;
    signal e_rnW_ram_rden     : std_logic;
	 signal ram_write_done		: std_logic;
	 signal internal_ram_read_done : std_logic;

    -- Signals from p_exponential_smoothing
    signal e_expsm_ram_address  : std_logic_vector(9 downto 0);
    signal e_expsm_ram_data_in  : std_logic_vector(63 downto 0);
    signal e_expsm_ram_data_out : std_logic_vector(63 downto 0) := (others => '0');
    signal e_expsm_ram_wren     : std_logic;
    signal e_expsm_ram_rden     : std_logic;

    -- Control Signals
	 signal start_smooth_process : std_logic := '0';
    --signal read_done     		  : std_logic;
	 signal smooth_process_done  : std_logic;
    signal mux_select   		  : std_logic := '0'; -- '0' for write/read entity, '1' for smoothing entity

    -- State Definitions
	 type state_type is (IDLE, RAM_PROCESS, EXPONENTIAL_SMOOTHING);
	 signal current_state, next_state : state_type := IDLE;

begin


    -- Instantiate p_exponential_smoothing
    e_es_inst : e_exponential_smoothing
        port map (
            clk           => clk,
            reset         => reset,
				process_start => start_smooth_process,
            process_done  => smooth_process_done,
            processed_out => smoothed_out,
            ram_address   => e_expsm_ram_address,
            ram_data_in   => e_expsm_ram_data_in,
            ram_wren      => e_expsm_ram_wren,
            ram_rden      => e_expsm_ram_rden,
            ram_data_out  => e_expsm_ram_data_out
        );
		  
    -- Instantiate e_write_and_read_ram
    e_wr_inst : e_write_and_read_ram
        port map (
            clk           => clk,
            reset         => reset,
            write_done    => ram_write_done,
            read_done     => internal_ram_read_done,
            ram_address   => e_rnw_ram_address,
            ram_data_in   => e_rnw_ram_data_in,
            ram_wren      => e_rnw_ram_wren,
            ram_rden      => e_rnw_ram_rden,
            ram_data_out  => e_rnw_ram_data_out
        );
	
    -- Multiplexing Logic for RAM Access
    mux_ram_address   <= e_rnW_ram_address  when mux_select = '0' else e_expsm_ram_address;
    mux_ram_data_in   <= e_rnW_ram_data_in  when mux_select = '0' else e_expsm_ram_data_in;
    mux_ram_wren      <= e_rnW_ram_wren     when mux_select = '0' else e_expsm_ram_wren;
    mux_ram_rden      <= e_rnW_ram_rden     when mux_select = '0' else e_expsm_ram_rden;
	 e_rnW_ram_data_out <= mux_ram_data_out when mux_select='0' else (others => '0');
	 e_expsm_ram_data_out <= mux_ram_data_out when mux_select='1' else (others => '0');
    -- Instantiate RAM
    ram_inst : config_ram
        port map (
            address => mux_ram_address,
            clock   => clk,
            data    => mux_ram_data_in,
            rden    => mux_ram_rden,
            wren    => mux_ram_wren,
            q       => mux_ram_data_out
        );

		  
	process (clk) 
	begin 
		if rising_edge(clk) then 
			if reset = '1' then 
				current_state <= IDLE;
			else 
				current_state <= next_state;
			end if;
		 end if;
	end process;
	
	process(current_state, internal_ram_read_done)
	begin
		mux_select <= '0';
		start_smooth_process <= '0';
		
		next_state <= current_state;
		
		case current_state is
			when IDLE => 
				mux_select <= '0';
				start_smooth_process <= '0';
				
				next_state <= RAM_PROCESS;
			when RAM_PROCESS => 
				 if internal_ram_read_done = '1' then 
					mux_select <= '1';
					next_state <= EXPONENTIAL_SMOOTHING;
				 else 
					mux_select <= '0';
					start_smooth_process <= '0';
					next_state <= RAM_PROCESS;
					end if;
			when EXPONENTIAL_SMOOTHING => 
					mux_select <= '1';
					start_smooth_process <= '1';
					next_state <= EXPONENTIAL_SMOOTHING;

		end case;
	end process;

end architecture behavioral;
